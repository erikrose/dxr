<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CurrentWorkingDirectory</key>
	<string>/Users/erose</string>
	<key>WorksheetContents</key>
	<string>def test_es():    es = ElasticSearch(ES_HOSTS)    try:        es.delete_index(INDEX)    except ElasticHttpNotFoundError:        pass    es.create_index(INDEX, settings={        'mappings': {            FILE: {                'properties': {                    'lines': {                        'type': 'nested'                    }                }            }        }})    es.bulk_index(INDEX, FILE, [            {                'id': 1,                'path': 'first',                'lines': [                    {                        'number': 1,                        'text': 'smart'                    },                    {                        'number': 2,                        'text': 'Good job.'                    }                ]            },            {                'id': 2,                'path': 'second',                'lines': [                    {                        'number': 3,                        'text': 'I like your hair.'                    },                    {                        'number': 4,                        'text': 'Your breath smells nice.'                    }                ]            }        ])curl -s -XGET 'localhost:9200/test_dxr/file/_search?pretty=1' -d '{  "query": {    "filtered": {      "query": {"match_all": {}},      "filter": {        "nested": {          "path": "lines",          "query":{            "filtered": {              "query": { "match_all": {}},              "filter": {                "and": [                  {"term": {"lines.text": "good"}},                  {"term": {"lines.text": "job"}}                ]              }            }          }        }      }    }  }}'# NEXT: Add a filter on path name and see if you can get it to work. If you can, you win.# Finds the whole doc (all lines, plus file-level data) for files with path "second" and with any line having "good" and "job".curl -s -XGET 'localhost:9200/test_dxr/file/_search?pretty=1' -d '{  "query": {    "filtered": {      "query": {"match_all": {}},      "filter": {        "and": [          {            "term": {"path": "first"}          },          {            "nested": {              "path": "lines",              "query":{                "filtered": {                  "query": { "match_all": {}},                  "filter": {                    "and": [                      {"term": {"lines.text": "good"}},                      {"term": {"lines.text": "job"}}                    ]                  }                }              }            }          }        ]      }    }  }}'{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "file",      "_id" : "1",      "_score" : 1.0, "_source" : {"path": "first", "lines": [{"text": "smart", "number": 1}, {"text": "Good job.", "number": 2}], "id": 1}    } ]  }}# Now, can we get it to not return all lines, both to save traffic and so we know what to display? Nope, though they're thinking about it: https://github.com/elasticsearch/elasticsearch/issues/3022. Also, highlighting doesn't work on inner objects, though it wouldn't be too much trouble to redo that app-side.curl -s -XGET 'localhost:9200/test_dxr/file/_search?pretty=1' -d '{  "fields": ["path", "lines"],  "highlight": {    "fields": {      "lines.text": {}    }  },  "query": {    "filtered": {      "query": {"match_all": {}},      "filter": {        "and": [          {            "term": {"path": "first"}          },          {            "nested": {              "path": "lines",              "query":{                "filtered": {                  "query": { "match_all": {}},                  "filter": {                    "and": [                      {"term": {"lines.text": "good"}},                      {"term": {"lines.text": "job"}}                    ]                  }                }              }            }          }        ]      }    }  }}'{  "took" : 25,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "file",      "_id" : "1",      "_score" : 1.0,      "fields" : {        "path" : "first",        "lines" : [ {          "text" : "smart",          "number" : 1        }, {          "text" : "Good job.",          "number" : 2        } ]      }    } ]  }}# Returns everything. But at least the returned shape is useful.curl -s -XGET 'localhost:9200/test_dxr/line/_search?pretty=1' -d '{  "fields": ["text", "_parent"],  "query": {    "filtered": {      "query": {"match_all": {}},      "filter": {        "has_parent": {          "parent_type": "file",          "query": {            "match_all": {}          }        }      }    }  }}'{  "took" : 1,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 4,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "3",      "_score" : 1.0,      "fields" : {        "_parent" : "2",        "text" : "Red fish"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "4",      "_score" : 1.0,      "fields" : {        "_parent" : "2",        "text" : "Red bull"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "One fish"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      }    } ]  }}# Returns all lines from the file with id=2:curl -s -XGET 'localhost:9200/test_dxr/line/_search?pretty=1' -d '{  "fields": ["text", "_parent"],  "query": {    "has_parent": {      "parent_type": "file",      "query": {        "text": {"id": "2"}      }    }  }}'{  "took" : 6,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "3",      "_score" : 1.0,      "fields" : {        "_parent" : "2",        "text" : "Red fish"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "4",      "_score" : 1.0,      "fields" : {        "_parent" : "2",        "text" : "Red bull"      }    } ]  }}# Return all lines from parent with a certain path:curl -s -XGET 'localhost:9200/test_dxr/line/_search?pretty=1' -d '{  "fields": ["text", "_parent"],  "query": {    "has_parent": {      "parent_type": "file",      "query": {        "text": {"path": "first"}      }    }  }}'{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "One fish"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      }    } ]  }}# Return only certain lines from a parent with a certain path:# IT WORKS! I can do a multi-get after the fact to grab the parent info.# NEXT: Can I sort by the parent's path? I'll need to do that if I want to keep the by-file by-line sorting of the current implementation without fetching ALL the results.curl -s -XGET 'localhost:9200/test_dxr/line/_search?pretty=1' -d '{  "fields": ["text", "_parent"],  "sort": ["_parent", "number"],  "query": {    "filtered": {      "query": {        "has_parent": {          "parent_type": "file",          "query": {            "text": {"path": "first"}          }        }      },      "filter": {        "term": {"text": "fish"}      }    }  }}'{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : null,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "One fish"      },      "sort" : [ "file#1", 1 ]    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      },      "sort" : [ "file#1", 2 ]    } ]  }}{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : null,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "One fish"      },      "sort" : [ "file#1", 1 ]    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      },      "sort" : [ "file#1", 2 ]    } ]  }}{  "took" : 3,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 3,    "max_score" : null,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "One fish"      },      "sort" : [ "file#1", 1 ]    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      },      "sort" : [ "file#1", 2 ]    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "3",      "_score" : null,      "fields" : {        "_parent" : "2",        "text" : "Red fish"      },      "sort" : [ "file#2", 1 ]    } ]  }}{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : null,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "One fish"      },      "sort" : [ "file#1", 1 ]    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      },      "sort" : [ "file#1", 2 ]    } ]  }}{  "took" : 33,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : null,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : null,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      },      "sort" : [ "file#1", 2 ]    } ]  }}{  "took" : 1,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      }    } ]  }}{  "took" : 1,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 1,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "One fish"      }    } ]  }}{  "took" : 2,  "timed_out" : false,  "_shards" : {    "total" : 5,    "successful" : 5,    "failed" : 0  },  "hits" : {    "total" : 2,    "max_score" : 1.0,    "hits" : [ {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "1",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "One fish"      }    }, {      "_index" : "test_dxr",      "_type" : "line",      "_id" : "2",      "_score" : 1.0,      "fields" : {        "_parent" : "1",        "text" : "Two fish"      }    } ]  }}curl -s -XGET 'localhost:9200/test_dxr/file/1?pretty=true'{  "_index" : "test_dxr",  "_type" : "file",  "_id" : "1",  "_version" : 1,  "exists" : true, "_source" : {"path": "first", "id": 1}}# IT WORKS! I can do a multi-get after the fact to grab the parent info.# NEXT: Can I sort by the parent's path? I'll need to do that if I want to keep the by-file by-line sorting of the current implementation without fetching ALL the results. At worst, I could use the file path as the file's ID. (Don't do that; ES holds all parent IDs in memory when doing a join. Put the parent path in a separate attr of the child instead.) At best, it's possible to actually sort on parent attrs: http://elasticsearch-users.115913.n3.nabble.com/Has-Parent-and-sorting-on-a-parent-s-properties-td4038559.html. Or I could just make sure the line IDs happen to come in order by file path, though that won't be simple/possible with incremental indexing.curl -s -XGET 'localhost:9200/test_dxr/line/_search?pretty=1' -d '{  "fields": ["text", "_parent"],  "sort": ["number"],  "query": {    "filtered": {      "query": {        "has_parent": {          "parent_type": "file",          "query": {            "text": {"path": "first"}          }        }      },      "filter": {        "term": {"text": "fish"}      }    }  }}'</string>
</dict>
</plist>
